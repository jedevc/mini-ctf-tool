#!/usr/bin/env python3

import argparse
import colorama
import glob
import json
import os
import re
import requests
import subprocess
import traceback
import urllib
from colorama import Fore, Style

UPSTREAM = 'https://raw.githubusercontent.com/jedevc/mini-ctf-tool/master/ctftool'


def main():
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers()

    create_parser = subparsers.add_parser('create', help='create a new challenge')
    create_parser.set_defaults(func=create_challenge)
    create_parser.add_argument('name', help='name of the challenge')
    create_parser.add_argument('category', help='category of the challenge')
    create_parser.add_argument('--path', help='path to the challenge')
    create_parser.add_argument('--preset', help='challenge preset', choices=PRESETS.keys())

    list_parser = subparsers.add_parser('list', help='list all challenges')
    list_parser.add_argument('--verbose', '-v', action='store_true', help='increase verbosity')
    list_parser.set_defaults(func=list_challenges)

    refresh_parser = subparsers.add_parser('refresh', help='format all config files')
    refresh_parser.set_defaults(func=refresh_challenges)

    run_parser = subparsers.add_parser('run', help='execute all scripts')
    run_parser.add_argument('script', help='script to run')
    run_parser.add_argument('--path', help='path of challenge to run')
    run_parser.set_defaults(func=run_challenges)

    upload_parser = subparsers.add_parser('upload', help='upload all challenges')
    upload_parser.add_argument('url', help='base url of the CTFd instance')
    upload_parser.add_argument('session', help='session cookie value')
    upload_parser.add_argument('--path', help='path of challenge to upload')
    upload_parser.set_defaults(func=upload_challenges)

    upgrade_parser = subparsers.add_parser('upgrade', help='upgrade ctftool')
    upgrade_parser.set_defaults(func=upgrade)

    args = parser.parse_args()
    if hasattr(args, 'func'):
        args.func(args)
    else:
        parser.print_help()


def create_challenge(args):
    path = args.path
    if path is None:
        path = os.path.join(args.category, args.name)
        path = path.lower().replace(' ', '')

    challenge = Challenge(args.name, args.category, path,
                          preset=args.preset, extra=PRESET_EXTRA.get(args.preset, {}))
    challenge.save()


def list_challenges(args):
    cache = {}
    for challenge in Challenge.load_all():
        if challenge.category not in cache:
            cache[challenge.category] = []

        cache[challenge.category].append(challenge)

    for category, challenges in cache.items():
        for challenge in challenges:
            print(f'[{challenge.category}] ', end='')
            print(f'{Style.BRIGHT}{challenge.name}{Style.RESET_ALL} ', end='')
            print(f'{Fore.LIGHTBLACK_EX}- {challenge.path}')
            if args.verbose:
                if '\n' in challenge.description:
                    INDENT = '\n\t\t'
                    description = INDENT + challenge.description.replace('\n', INDENT)
                else:
                    description = challenge.description

                print(f'\tdescription: {description}')
                print(f'\tpoints: {challenge.points}')
                print(f'\tflags: {challenge.flags}')
                print(f'\tfiles: {challenge.files}')


def refresh_challenges(args):
    for challenge in Challenge.load_all():
        challenge.save()


def run_challenges(args):
    for challenge in Challenge.load_all(args.path):
        challenge.run(args.script)


def upload_challenges(args):
    ctfd = CTFd(args.url, args.session)

    try:
        online = ctfd.list()
    except Exception:
        online = []

    for challenge in Challenge.load_all(args.path):
        print(f'[{challenge.category}] {Style.BRIGHT}{challenge.name} ', end='')
        if (challenge.name, challenge.category) in online:
            print(Fore.YELLOW + '○')
        else:
            try:
                ctfd.upload(challenge)
                print(Fore.GREEN + '✓')
            except Exception as e:
                print(Fore.RED + '✗ ' + repr(e))


def upgrade(args):
    # download new code
    response = urllib.request.urlopen(UPSTREAM)
    source_code = response.read().decode()

    # write code
    path = os.path.realpath(__file__)
    with open(path, 'w') as ctftool:
        ctftool.write(source_code)


PRESETS = {
    'docker': {
        'start': ['docker run -p {port}:4000 -d {image}'],
        'kill': ['docker kill `docker ps -f ancestor={image} -q`'],
        'build': ['docker build . -t {image}']
    }
}

PRESET_EXTRA = {
    'docker': {
        'port': 4000,
        'image': ''
    }
}


class Challenge:
    '''
    Interface to the challenge files and their contained data.
    '''

    FILE_NAME = 'challenge.json'

    def __init__(self, name, category, path, description='', points=0, preset=None, scripts=None, extra=None):
        self.name = name
        self.category = category
        self.path = path
        self.description = '\n'.join(from_json_multipart(description))
        self.points = points
        self.flags = []
        self.files = []

        self.preset = preset
        if scripts is None:
            self.scripts = {}
        else:
            self.scripts = {k: from_json_multipart(v) for k, v in scripts.items()}
        self.extra = extra or {}

    def run(self, script_name='start', cwd='.'):
        # run defined scripts
        script = self.scripts.get(script_name)
        if script:
            for part in script:
                part = part.format(**self.extra)
                subprocess.run(part, shell=True, cwd=self.path)

        # run preset scripts
        if self.preset in PRESETS and script_name in PRESETS[self.preset]:
            preset_script = PRESETS[self.preset][script_name]
            for part in preset_script:
                part = part.format(**self.extra)
                subprocess.run(part, shell=True, cwd=self.path)

    def load(file):
        data = json.load(file)
        ch = Challenge._load_json(data)
        ch.path = os.path.dirname(file.name)
        return ch

    def load_all(directory=None):
        if directory:
            globpath = os.path.join(directory, '**', Challenge.FILE_NAME)
        else:
            globpath = os.path.join('**', Challenge.FILE_NAME)

        paths = glob.glob(globpath, recursive=True)
        for path in paths:
            with open(path) as f:
                challenge = Challenge.load(f)
                yield challenge

    def save(self):
        os.makedirs(self.path, exist_ok=True)
        challenge_file = os.path.join(self.path, Challenge.FILE_NAME)
        with open(challenge_file, 'w') as f:
            data = self._save_json()
            json.dump(data, f, indent=4)

    def _load_json(data):
        ch = Challenge(name=data.get('name', ''),
                       category=data.get('category', ''),
                       path=None,
                       points=data.get('points', 0),
                       description=data.get('description', ''),
                       preset=data.get('preset'),
                       scripts=data.get('scripts', {}),
                       extra=data.get('extra', {}))
        ch.flags = data.get('flags', [])
        ch.files = data.get('files', [])
        return ch

    def _save_json(self):
        description = to_json_multipart(self.description.split('\n'))
        scripts = {k: to_json_multipart(v) for k, v in self.scripts.items()}

        return {
            'name': self.name,
            'category': self.category,
            'description': description,
            'points': self.points,
            'flags': self.flags,
            'files': self.files,
            'preset': self.preset,
            'scripts': scripts,
            'extra': self.extra
        }

    def __str__(self):
        return self.name


def from_json_multipart(obj):
    if obj is None:
        return []
    elif hasattr(obj, 'append'):
        return obj
    else:
        return [obj]


def to_json_multipart(li):
    if len(li) == 0:
        return None
    elif len(li) == 1:
        return li[0]
    else:
        return li


class CTFd:
    """
    Client for CTFd server.

    This was originally tested with CTFd 2.1.1 on API v1 and should continue
    to work in the future, as long as the API doesn't change too much.

    Note that this is very hacky - it is near impossible to find any
    documentation on the CTFd api.
    """

    NONCE_EXPRESSION = re.compile('var csrf_nonce = *"([a-zA-Z0-9]*)"')

    def __init__(self, url, session_token):
        self.base = url

        self.session = requests.Session()
        self.session.cookies['session'] = session_token

        self.nonce = None
        self._extract_nonce()

    def list(self):
        headers = {
            'CSRF-Token': self.nonce
        }

        resp = self.session.get(self.base + '/api/v1/challenges',
                                headers=headers)
        resp = resp.json()
        if 'success' in resp and resp['success']:
            return [(item['name'], item['category']) for item in resp['data']]

    def upload(self, challenge):
        headers = {
            'CSRF-Token': self.nonce
        }

        data = {
            'name': challenge.name,
            'category': challenge.category,
            'state': 'visible',
            'value': challenge.points,
            'type': 'standard',
            'description': challenge.description
        }
        resp = self.session.post(self.base + '/api/v1/challenges',
                                 headers=headers, json=data)
        resp = resp.json()
        if 'success' not in resp or not resp['success']:
            raise RuntimeError('could not add challenge')

        challenge_id = resp['data']['id']

        for flag in challenge.flags:
            data = {
                'challenge': challenge_id,
                'content': flag,
                'type': 'static'
            }
            resp = self.session.post(self.base + '/api/v1/flags',
                                     headers=headers, json=data)
            resp = resp.json()
            if 'success' not in resp or not resp['success']:
                raise RuntimeError('could not add flag to challenge')

        for filename in challenge.files:
            fullfilename = os.path.join(challenge.path, filename)
            data = {
                'nonce': self.nonce,
                'challenge': challenge_id,
                'type': 'challenge'
            }
            files = {
                'file': (filename, open(fullfilename, 'rb'))
            }

            resp = self.session.post(self.base + '/api/v1/files',
                                     data=data, files=files)
            resp = resp.json()
            if 'success' not in resp or not resp['success']:
                raise RuntimeError('could not add file to challenge')

    def _extract_nonce(self):
        resp = self.session.get(self.base)
        matches = CTFd.NONCE_EXPRESSION.search(resp.content.decode())
        if matches:
            self.nonce = matches.group(1)


if __name__ == "__main__":
    colorama.init(autoreset=True)
    try:
        main()
    except Exception:
        traceback.print_exc()
    finally:
        colorama.deinit()
